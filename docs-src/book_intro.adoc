[preface]
= Introduction

:Skein: http://inform7.com/book/WI_1_7.html[Skein^, title="Writing with Inform » §1.7. The Skein"]
:Inform7: http://inform7.com/[Inform{nbsp}7^, title="Inform 7 website"]

Embarking on the adventure of creating a PureBasic version of the ARun interpreter was a fun-project I had in mind for quite some time, mostly as a mean to learn the inner-workings of ARun and its Amachine.

But there are also practical reasons for doing so, for I always wanted to create an ALAN version of {Inform7}`'s {Skein} tool along with an ALAN visual debugger -- two projects which could benefit from PureBasic's cross-platform GUI components.
If I succeed in creating either one of these tools, the ARun PureBasic codebase could lead to a dedicated ALAN IDE written entirely in PureBasic.

Since these goals are still far from reach, for the time being this project will offer me a change to document ARun's design and the ALAN storyfile format (none of which are currently documented).


== Methodology and Conventions

In the course of this book I'll try to describe the inner workings of ARun in a language agnostic way, in order to simplify creating an ALAN interpreter in any language.
At the same time, I shall provide references to the original C sources of ARun, including code excerpts, based on the assumption that to fully understand ARun it's necessary to study its source code.
Finally, since this document was created in relation to my PureBasic port of ARun, I shall also add PureBasic specific notes and code examples, when needed.

When discussing primitive scalar data types, I'll resort to Rust's types naming convention which provides a more immediate representation of the types in terms of their width/precision, signedness, etc. -- e.g. `i32` and `i64` represent signed integers of 32- and 64-bit width, respectively, whereas `u32` and `u64` represent their unsigned counterparts.
This approach should dispel any ambiguities about the C types (which are often subject to different architecture or compiler interpretations) and PureBasic's bizarre naming of its native types.


== ARun {revnumber}

All references to the upstream ARun code, and excerpts thereof, refer to ARun v{revnumber}.
The upstream ARun v{revnumber} sources can be viewed on GitHub at:

* https://github.com/alan-if/alan/tree/v{revnumber}/interpreter

This decision to stick with a specific version is motivated by the fact that I wanted to have a fixed codebase to work on, without having to deal with upstream code changes and their integration in the book.

Although this might be a limiting choice in the long run, I'm not expecting to switch to another ARun version until it reaches v3.0 stable release, or unless its source code undergoes major changes (which is fairly unlikely right now).

The aim of this book is to introduce the reader to the inner workings of ARun, its data structures, the Amachine, etc.; having learnt these, he/she should be able to easily work with the latest upstream source code, regardless of any new changes to it.


== ALAN Types

The basic ALAN Amachine/ACODE native types are are all 32-bit integers, either signed (`i32`) or unsigned (`u32`).
Their definition is found in arunsrc:acode.h[10].

[cols="<m,>m,<d",options="autowidth",role=center]
|=========================================================
| alan type | int | description

| Aaddr     | u32 | ACODE address in Amemory
| Abool     | u32 | ACODE Boolean value
| Aid       | u32 | ACODE Instance Id value
| Aint      | i32 | ACODE Integer value
| Aptr      | u32 | Mapped pointer, used in the structures
| Aset      | u32 | ACODE Set value
| Aword     | u32 | ACODE word
| CodeValue | i32 | Definition for the packing process
|=========================================================

These (and a few others) are the native ALAN types that will be encountered in the storyfile data and its structures, and in the Amachine actual code.

////
My note from "acode-datatypes.pbi":

; NOTE: Here's the major 32->64bit problem: Aptrs are 32 bit to fit into the
;       32-bit structure of the Amachine, but sometimes this is used to store
;       a *real* pointer value, which on 64-bit machines are 64-bit.
;       So an Aptr is a symbolic value for the actual address and has to be
;       translated through fromAptr() in memory.c

Note from original source ("acode.h" L.10):

typedef uint32_t Aptr;       /* Type for a mapped possibly 64-bit pointer used in the structures */
/* Aptrs are 32 bit to fit into the 32-bit structure of the Amachine,
   but represents a *real* pointer value, which on 64-bit machines are
   64bits. So an Aptr is a symbolic value for the actual address and
   has to be translated through fromAptr() in memory.c
 */
////

The `Aptr` type is a special case, due to its role of mapping real pointers in memory.
It will be discussed in detail elsewhere, but for the time being here's the excerpt of its source definition, along with comments:

[source,c]
---------------------------------------
include::{arun_c}/acode.h[lines=10..15]
---------------------------------------

